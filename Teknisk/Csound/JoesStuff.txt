with_fx :reverb, mix: 0.25, room: 100, wet: 0.5, decay: 0.9{
live_loop :name do
    stop
    tick
#    stop
  with_fx(:echo, room: 200, mix: 0.2, decay: 0.5, phase: (ring 0.25, 0.125, 0.5).look) {

      #stop
      if spread(4*2,8*2).look
        #sample Voices[/./].look, num_slices: 65, slice: rand_i(65), attack: 0.01, amp: 1.7
        at{
          sample Voices[/./].look, onset: 1
          sleep 0.5
          sample Voices[/./].look, onset: 2
        }
      else
        sample Voices[/./].look, num_slices: 24*2, slice: 10, attack: 0.01, amp: 2.0
      end





      if spread(1,4).look
        #sample Voices[/./].look, num_slices: 25, slice: 24
      end
  #sample Voices[/english/].look, onset: (ing 1,2,3,4,5,6,7,8).look, amp: 2

  #sample Voices[/./].look num_slices: 335, slice: 1
 }

  #smp Mountain[/subkick/,1], amp: 2 if spread(7,11).look

    # if spread(7,11).look
    #   sample Voices[/./].tick, num_slices: 25, slice: 1, attack: 0.1, amp: 1.7
    # end

    # if spread(3,7).look
    #   sample Voices[/./].tick, num_slices: 25, slice: 24, attack: 0.01, amp: 1.7
    # end

  sleep 1.0
  end
  }







module Voices
  @sample_cache = nil; @matcher_lookup = {}
  def self.[](*a)
    root = "/Users/josephwilk/Workspace/josephwilk/clojure/speech_accent/waves/"
    unless @sample_cache; @sample_cache = Sample.glob("#{root}/**/*.wav"); end
    Sample.matches(@sample_cache, a, @matcher_lookup)
  end
end


module Sample
def self.cache_key(keys)
  keys.join("-")
end

def self.cached(matchers, match_cache)
  match_cache[Sample.cache_key(matchers)]
end

def self.glob(str)
  Dir[str].sort!
end

def self.filter_samples(samples, matchers)
  r = matchers.reduce(samples) do |filtered_samples,filter|
    if filtered_samples && !filtered_samples.empty?
      if filter.is_a?(Integer)
        filter = filter % filtered_samples.size
        [filtered_samples[filter]]
      elsif filter.is_a? Regexp
        if filter.inspect[-1] == "/" #We have no flags
          reg_str = filter.inspect[1..-2]
          filter = Regexp.new(reg_str,"i")
        end
        filtered_samples.select{|s| s=~ filter}
      elsif filter.is_a? Range
        filter.to_a.map{|f| Sample.filter_samples(filtered_samples, [f])}
      elsif filter.is_a? SonicPi::Core::RingVector
        filter.to_a.map{|f| Sample.filter_samples(filtered_samples, [f])}
      elsif filter.is_a? Array
        filter.map{|f| Sample.filter_samples(filtered_samples, [f])}
      elsif filter == nil
        nil
      else
        filtered_samples.select{|s| s=~ /#{filter}/i}
      end
    end
  end
  result_set = if r && r.length == 1
    r[0]
  else
    if r && !r.empty?
      SonicPi::Core::RingVector.new(r)
    end
  end
  result_set
end

def self.matches(samples, matchers, match_cache)
  result_set = Sample.cached(matchers, match_cache)
  return result_set if result_set
  result_set = filter_samples(samples, matchers)
  match_cache[Sample.cache_key(matchers)] ||= result_set
end
end
